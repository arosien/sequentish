= You Didn't Know It, but You Really Want to Learn Sequent Calculus
:customcss: ip-big.css
:highlightjs-languages: scala
:revealjs_center: false
:revealjs_hash: true
:revealjs_theme: black
:revealjs_height: 800
:revealjs_width: 1200
:sourcedir: ../scala/net/rosien/sequentish
:source-highlighter: highlightjs
:stem:
:tip-caption: 🔊

Adam Rosien https://twitter.com/arosien[`@arosien`]

Inner Product LLC https://inner-product.com[`inner-product.com`]

== !

[cols="2a,^.^a",frame=none,grid=none]
|===
| image::Chymyst_curryhoward.jpg[] |
[.fragment]
[.big_emoji]#ʘ‿ʘ#
|===

[.fragment]
[cols="2a,^.^a",frame=none,grid=none]
|===
| Sequents? Proofs? +
WTH is LJT? Why did I start this!? |
[.fragment]
[.big_emoji]#( ͡ಠ ʖ̯ ͡ಠ)#
|===

[.fragment]
[cols="2a,^.^a",frame=none,grid=none]
|===
| Fake it 'til you make it! +
(but use [.strategyNotBig]#programming strategies#!) | [.big_emoji]#(ᵔᴥᵔ)#
|===


=== Our Goal

> given a [.accent]#*type signature*#, +
> automatically derive a [.accent]#*program*#


=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color=white
    fontcolor=white
    fontname="times-italic"
    style=dashed

    formula [fontcolor=white]
    proof [fontcolor=white]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=white,fontcolor=white]
  program -> type [label="type\ninference",color=white,fontcolor=white]
  formula -> type [xlabel="Curry-Howard",dir=both,color=white,fontcolor=white]
  program -> proof [label="Curry-Howard",dir=both,color=white,fontcolor=white]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....

=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color=white
    fontcolor=white
    fontname="times-italic"
    style=dashed

    formula [fontcolor=white]
    proof [fontcolor=white]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=red3]
  program -> type [label="type\ninference",color=white,fontcolor=white]
  formula -> type [xlabel="Curry-Howard",dir=both,color=white,fontcolor=white]
  program -> proof [label="Curry-Howard",dir=both,color=white,fontcolor=white]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....

=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color=white
    fontcolor=white
    fontname="times-italic"
    style=dashed

    formula [fontcolor=white]
    proof [fontcolor=white]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=red3]
  program -> type [label="type\ninference",color=red3]
  formula -> type [xlabel="Curry-Howard",dir=both,color=white,fontcolor=white]
  program -> proof [label="Curry-Howard",dir=both,color=white,fontcolor=white]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....

=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=red3]
  program -> type [label="type\ninference",color=red3]
  formula -> type [xlabel="Curry-Howard",dir=both,color=white,fontcolor=white]
  program -> proof [label="Curry-Howard",dir=both,color=white,fontcolor=white]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....


=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=red3]
  program -> type [label="type\ninference",color=red3]
  formula -> type [xlabel="Curry-Howard  ",dir=both,color=purple3]
  program -> proof [label="  Curry-Howard",dir=both,color=purple3]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....


=== !

[graphviz]
....
include::curry-howard.dot[]
....

=== !

[graphviz]
....
include::curry-howard-goal.dot[]
....

== Types ⇒ Formulas

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"

  node [shape=none]
  edge [color=grey fontcolor=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  formula -> proof [label=<<b>?</b>>,color=grey,fontcolor=grey,style=bold]
  program -> type [label="type\ninference",color=grey]
  type -> program [label="programmers",color=grey]

  formula -> type [xlabel="Curry-Howard  ",dir=both,color=grey]
  program -> proof [xlabel="  Curry-Howard",dir=both,color=grey]

  type -> formula [label=<<b>  ?</b>>,color=green3,fontcolor=green3,style=bold]
  proof -> program [xlabel=<<b>? </b>>,color=grey,fontcolor=grey,style=bold]
}
....

=== !

[cols=">,<",frame=none,grid=none]
|===
| Type | Formula

| [.theory]#`Unit`# | [.theory]#⊤# 🔊 "_true_"
| [.theory]#`Nothing`# | [.theory]#⊥# 🔊 "_false_"
2*| [.theory]#`A`#, ... 
| [.theory]#`(A, B)`# | [.theory]#`A ∧ B`# 🔊 "_and_"
| [.theory]#`Either[A, B]`# | [.theory]#`A ∨ B`# 🔊 "_or_"
| [.theory]#`A ⇒ B`# | [.theory]#`A ⇒ B`# 🔊 "_implies_"
|===

TODO: type params, universals, existentials.

=== !

[source,scala]
----
include::{sourcedir}/Formula.scala[tag=all]
----

[.strategy]#Reification# [.strategy]#Algebraic Data Type#

=== Example: Type ⇒ Formula

[source,scala]
----
type Example = (A, Either[B, C])

val example =
  Formula.And(
    Formula.Type("A")
    Formula.Or(
      Formula.Type("B"),
      Formula.Type("C")))
----

=== 💯Pretty-Printing with `Show`

[source,scala]
include::{sourcedir}/Formula.scala[tag=show]

=== 💯Pretty-Printing with `Show`

[source,scala]
----
// (A, Either[B, C])
val example =
  Formula.And(
    Formula.Type("A")
    Formula.Or(
      Formula.Type("B"),
      Formula.Type("C")))
example.show
----

[.console]
----
(A ∧ (B ∨ C))
----

=== Type ⇒ Formula

[source,scala]
----
include::{sourcedir}/ToFormula.scala[tag=ToFormula-def]
----
[.strategy]#Typeclass#

=== Type ⇒ Formula

[source,scala]
----
trait A
trait B
trait C

implicit val toFormulaA = ToFormula.reify[A]
implicit val toFormulaB = ToFormula.reify[B]
implicit val toFormulaC = ToFormula.reify[C]

ToFormula[(A, Either[B, C])].toFormula.show
----

[.console]
----
(A ∧ (B ∨ C))
----

=== Type ⇒ Formula

[source,scala]
----
include::{sourcedir}/ToFormula.scala[tag=product]

include::{sourcedir}/ToFormula.scala[tag=sum]
----

[.strategy]#Typeclass Derivation#

== Formulas ⇒ Proofs

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"

  node [shape=none]
  edge [color=grey fontcolor=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  formula -> proof [label=<<b>?</b>>,color=green3,fontcolor=green3,style=bold]
  program -> type [label="type\ninference",color=grey]
  type -> program [label="programmers",color=grey]

  formula -> type [xlabel="Curry-Howard  ",dir=both,color=grey]
  program -> proof [xlabel="  Curry-Howard",dir=both,color=grey]

  type -> formula [label=<<b>  typeclass</b>>,color=green3,fontcolor=green3,style=bold]
  proof -> program [xlabel=<<b>? </b>>,color=grey,fontcolor=grey,style=bold]
}
....

=== !

[source,scala]
----
trait Prover[Rule] {
  def prove(formula: Formula): Proof[Rule]
}

sealed trait Proof[Rule] // TODO
----

=== !

Please prove this type:

[.theory]#`Unit`#

[.fragment]
> 🔊 "Give me a `Unit`."

[.fragment]
[.whee]#`val proof = ()`#

=== !

Please prove this type:

[.theory]#`A`#

[.fragment]
> 🔊 "Give me an `A`."

[.fragment]
[.whee]#`val proof = ???`#

=== !

Please prove this type:

[.theory]#`A => A`#

[.fragment]
> 🔊 "If you give me an `A`, I'll give you an `A`."

[.fragment]
[.whee]#`val proof = (a: A) => a`#

=== !

Please prove this type:

[.theory]#`(A, B) => A`#

[.fragment]
> 🔊 "If you give me an `A` and a `B`, +
 I'll give you an `A`."

[.fragment]
[.whee]#`val proof = (a: A, _: B) => a`#

=== !

Please prove this type:

[.theory]#`A => Either[A, B]`#

[.fragment]
> 🔊 "If you give me an `A`, I'll give you an `A` or `B`."

[.fragment]
[.whee]#`val proof = (a: A) => Right(a)`#

=== !

[.notes]
--
We need to be explicit about when we are treating formulas as black boxes, i.e., functions like `A => A`, vs. treating formulas as _premises_ or _conclusions._
--

How did you know how to do that?

[.fragment]
Can we teach a computer?

=== More Complex Formulas

Please prove this type:

[.theory]#`(A, B) => Either[A, C]`#

[.fragment]
[.whee]
----
val proof1a: (A, B) => A =
  (a: A, _) => a

val proof2: A => Either[A, B] =
  (a: A) => Right(a)

val proof: (A, B) => Either[A, B] =
  proof1a andThen proof2
----

[.fragment]
====
Notice we didn't use this proof:

[.whee]
----
val proof1b: (A, B) => B =
  (_, b: B) => b
----
====

=== !

Formulas are _compositional_: they are composed of other formulas.

We have a set of primitive rules that translate formulas into simpler formulas.

Proof system: find rules to simplify formulas, until they are so simple they are axiomatically true.

The sequence of rules and formula transformations is the _proof_.

But we need a data structure to store the state: a _sequent_.

:GammaDelta: pass:m[stem:[Gamma |-- Delta]]
:entails: pass:m[stem:[|--]]

=== !

[cols=">,2,",grid=cols,frame=none]
|===
| If we had | Could we produce? | 

| | [.theory]#`(A, B) => Either[A, C]`# | no
|===
[.fragment]
[cols=">,2,",grid=cols,frame=none]
|===
| | ↙︎ ↓ extract args |
| [.theory]#`(A, B)`# | [.theory]#`Either[A, C]`# | no 
|===
[.fragment]
[cols=">,2,",grid=cols,frame=none]
|===
| un-pair ↓ |  |
| [.theory]#`A, B`# | [.theory]#`Either[A, C]`# | no
|===
[.fragment]
[cols=">,2,",grid=cols,frame=none]
|===
|  | ↓ choose `A` | 
| [.theory]#`A, B`# | [.theory]#`A`# | *Yes!* 
|===

=== !

[cols=">,,",grid=cols,frame=none]
|===
| If we had | Could we produce? | 

| | [.theory]#`(A, B) => Either[A, C]`# | [.whee]`(a, _) => Right(a)`
| | ↙︎ ↓ extract args | ↑
| [.theory]#`(A, B)`# | [.theory]#`Either[A, C]`# | ↑
| un-pair ↓ |  | ↑
| [.theory]#`A, B`# | [.theory]#`Either[A, C]`# | [.whee]`(a, _) => Right(a)`
|  | ↓ choose `A` | ↑ [.whee]`_ andThen Right(_)`
| [.theory]#`A, B`# | [.theory]#`A`# | [.whee]`(a, _) => a` 
|===

=== !

[.theory]#`A => A`#

> 🔊 "If you give me an [.theory]#`A`#, I'll give you an [.theory]#`A`#."

[.fragment]
====
↓

> 🔊 "If I [.whee]#presume# I have an [.theory]#`A`#, +
I can [.whee]#conclude# I have an [.theory]#`A`# (that I can give)."
====

[.fragment]
====
↓

[.theory]#`A ⊢ A`#
====

=== Sequents

[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#`A ⊢ A`# | > 🔊 "If we presume [.theory]#`A`#, we can conclude [.theory]#`A`#."
|===

[.fragment]
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#{GammaDelta}# |
> 🔊 "If the premise [.theory]#Gamma# is true, then the conclusion [.theory]#Delta# is true."
|===

[.fragment]
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#{entails}# | > 🔊 "entails"
|===

[.fragment]
[source,scala]
----
case class Sequent(
  premises: List[Formula],
  conclusion: Formula)
----

== Proving Sequents

=== !

[.theory]#`A => A`#

> 🔊 "If you give me an [.theory]#`A`#, I'll give you an [.theory]#`A`#."

[.fragment]
====
↓

[.theory]#`⊢ A => A`#

> 🔊 "If we presume nothing, +
we can conclude [.theory]#`A => A`#."
====

=== !
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#`⊢ A => A`# | > 🔊 "If we presume nothing, we can conclude [.theory]#`A => A`#."
|===

[.fragment]
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#`A ⊢ A`# | > 🔊 "If I [.whee]#presume# I have an [.theory]#`A`#, I can [.whee]#conclude# I have an [.theory]#`A`# (that I can give)."
|===

[.fragment]
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.big_emoji]#`ಠ‿ಠ`# | > 🔊 "That's obviously true. I'm done!"
|===

=== Reduction ↓

[.theory]
stem:[(A |-- B)/(|-- A => B)R=>]

> 🔊 "if we presume [.theory]#stem:[A |-- B]#, +
then we can conclude [.theory]#stem:[|-- A => B]#".

=== Deduction ↑

[.theory]
stem:[(A |-- B)/(|-- A => B)R=>]

> 🔊 "if we conclude [.theory]#stem:[|-- A => B]#, +
then we can presume [.theory]#stem:[A |-- B]#".

=== Inference Rules

:Rimp: pass:m[stem:[(Gamma, A |-- B)/(Gamma |-- A => B)R=>]]

[cols="^.^a,>.^a,<2a",grid=none,frame=none]
|===
.2+| [.theory]#{Rimp}#
>| [.theory]#stem:[Gamma]# <| > 🔊 "whatever"
>| [.theory]#stem:[R=>]# <| > 🔊 "the rule R⇒"
|===

[source,scala]
----
case LK.`R⇒` => {
  case Sequent(g, Formula.Implies(a, b)) =>
    Deduction.Success(
      rule,
      NonEmptyList.of(Sequent(a :: g, b)))
}
----


=== Inference Rules

[.theory]
stem:[(<premise_1>, <premise_2>, ...)/(<conclusion>)<name>]

[.fragment]
Does this remind you of something?

[.fragment]
[grid=none,frame=none]
|===
^| Reduction ↓ | premises => conclusion
^| Deduction ↑ | conclusion => premises
|===

=== !

[.theory]
latexmath:[\dfrac{\dfrac{\dfrac{\dfrac{}{A, B \vdash A}Id}{A, B \vdash A \vee C}R\vee1}{A \wedge B \vdash A \vee C}L\wedge}{\vdash A \wedge B \Rightarrow A \vee C}R\Rightarrow]

== Proofs ⇒ Programs

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"

  node [shape=none]
  edge [color=grey fontcolor=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  formula -> proof [label=<<b>proof system</b>>,color=green3,fontcolor=green3,style=bold]
  program -> type [label="type\ninference",color=grey]
  type -> program [label="programmers",color=grey]

  formula -> type [xlabel="Curry-Howard  ",dir=both,color=grey]
  program -> proof [xlabel="  Curry-Howard",dir=both,color=grey]

  type -> formula [label=<<b>  typeclass</b>>,color=green3,fontcolor=green3,style=bold]
  proof -> program [xlabel=<<b>? </b>>,color=green3,fontcolor=green3,style=bold]
}
....

== Summary

=== type => program in 3 Steps

[cols="a,2a"]
|===
^.^| type => [.accent]#formula# |
[.strategyNotBig]#reification# +
[.strategyNotBig]#algebraic data type# +
[.strategyNotBig]#typeclass#
^.^| formula => [.accent]#proof# |
[.strategyNotBig]#reification# +
[.strategyNotBig]#algebraic data type# +
[.strategyNotBig]#typeclass# +
[.strategyNotBig]#intepreter#
^.^| proof => [.accent]#program# |
[.strategyNotBig]#intepreter#
|===

=== !

[source,scala]
----
sealed trait Formula
----

[.fragment]
[source,scala]
----
case class Sequent(
  premises: List[Formula],
  conclusion: Formula)
----

[.fragment]
[source,scala]
----
case class System[Rule](rules: NonEmptySet[Rule])
----

[.fragment]
[source,scala]
----
trait Deducer[Rule] {
  def deduce(rule: Rule): Sequent => Deduction[Rule]
}
----

[.fragment]
[source,scala]
----
trait Prover[Rule] {
  def prove(sequent: Sequent): Proof[Rule]
}
----

=== Thank you!

Adam Rosien https://twitter.com/arosien[`@arosien`]

Inner Product LLC https://inner-product.com[`inner-product.com`]

[.accent]#**_Hire us to teach your team!_ ☝︎**#

'''

References and Links:

- https://github.com/Chymyst/curryhoward
- https://en.wikipedia.org/wiki/Sequent_calculus
- http://logitext.mit.edu/main