= You Didn't Know It, but You Really Want to Learn Sequent Calculus
:customcss: ip-big.css
:highlightjs-languages: scala
:revealjs_center: false
:revealjs_hash: true
:revealjs_theme: black
:revealjs_height: 800
:revealjs_width: 1200
:sourcedir: ../scala/net/rosien/sequentish
:source-highlighter: highlightjs
:stem:
:tip-caption: üîä

Adam Rosien https://twitter.com/arosien[`@arosien`]

Inner Product LLC https://inner-product.com[`inner-product.com`]

== !

[cols="2a,^.^a",frame=none,grid=none]
|===
| image::Chymyst_curryhoward.jpg[] |
[.fragment]
[.big_emoji]# ò‚Äø ò#
|===

[.fragment]
[cols="2a,^.^a",frame=none,grid=none]
|===
| Sequents? Proofs? +
WTH is LJT? Why did I start this!? |
[.fragment]
[.big_emoji]#( Õ°‡≤†  ñÃØ Õ°‡≤†)#
|===

[.fragment]
[cols="2a,^.^a",frame=none,grid=none]
|===
| Fake it 'til you make it! +
(but use [.strategyNotBig]#programming strategies#!) | [.big_emoji]#(·µî·¥•·µî)#
|===


=== Our Goal

> given a [.accent]#*type signature*#, +
> automatically derive a [.accent]#*program*#


=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color=white
    fontcolor=white
    fontname="times-italic"
    style=dashed

    formula [fontcolor=white]
    proof [fontcolor=white]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=white,fontcolor=white]
  program -> type [label="type\ninference",color=white,fontcolor=white]
  formula -> type [xlabel="Curry-Howard",dir=both,color=white,fontcolor=white]
  program -> proof [label="Curry-Howard",dir=both,color=white,fontcolor=white]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....

=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color=white
    fontcolor=white
    fontname="times-italic"
    style=dashed

    formula [fontcolor=white]
    proof [fontcolor=white]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=red3]
  program -> type [label="type\ninference",color=white,fontcolor=white]
  formula -> type [xlabel="Curry-Howard",dir=both,color=white,fontcolor=white]
  program -> proof [label="Curry-Howard",dir=both,color=white,fontcolor=white]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....

=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color=white
    fontcolor=white
    fontname="times-italic"
    style=dashed

    formula [fontcolor=white]
    proof [fontcolor=white]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=red3]
  program -> type [label="type\ninference",color=red3]
  formula -> type [xlabel="Curry-Howard",dir=both,color=white,fontcolor=white]
  program -> proof [label="Curry-Howard",dir=both,color=white,fontcolor=white]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....

=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=red3]
  program -> type [label="type\ninference",color=red3]
  formula -> type [xlabel="Curry-Howard",dir=both,color=white,fontcolor=white]
  program -> proof [label="Curry-Howard",dir=both,color=white,fontcolor=white]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....


=== !

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"
  node [shape=none]
  edge [color=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  type -> program [label="programmers",color=red3]
  program -> type [label="type\ninference",color=red3]
  formula -> type [xlabel="Curry-Howard  ",dir=both,color=purple3]
  program -> proof [label="  Curry-Howard",dir=both,color=purple3]
  formula -> proof [label="logical system",color=white,fontcolor=white]
}
....


=== !

[graphviz]
....
include::curry-howard.dot[]
....

=== !

[graphviz]
....
include::curry-howard-goal.dot[]
....

== Types ‚áí Formulas

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"

  node [shape=none]
  edge [color=grey fontcolor=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  formula -> proof [label=<<b>?</b>>,color=grey,fontcolor=grey,style=bold]
  program -> type [label="type\ninference",color=grey]
  type -> program [label="programmers",color=grey]

  formula -> type [xlabel="Curry-Howard  ",dir=both,color=grey]
  program -> proof [xlabel="  Curry-Howard",dir=both,color=grey]

  type -> formula [label=<<b>  ?</b>>,color=green3,fontcolor=green3,style=bold]
  proof -> program [xlabel=<<b>? </b>>,color=grey,fontcolor=grey,style=bold]
}
....

=== !

[cols=">,<",frame=none,grid=none]
|===
| Type | Formula

| [.theory]#`Unit`# | [.theory]#‚ä§# üîä "_true_"
| [.theory]#`Nothing`# | [.theory]#‚ä•# üîä "_false_"
2*| [.theory]#`A`#, ... 
| [.theory]#`(A, B)`# | [.theory]#`A ‚àß B`# üîä "_and_"
| [.theory]#`Either[A, B]`# | [.theory]#`A ‚à® B`# üîä "_or_"
| [.theory]#`A ‚áí B`# | [.theory]#`A ‚áí B`# üîä "_implies_"
|===

TODO: type params, universals, existentials.

=== !

[source,scala]
----
include::{sourcedir}/Formula.scala[tag=all]
----

[.strategy]#Reification# [.strategy]#Algebraic Data Type#

=== Example: Type ‚áí Formula

[source,scala]
----
type Example = (A, Either[B, C])

val example =
  Formula.And(
    Formula.Type("A")
    Formula.Or(
      Formula.Type("B"),
      Formula.Type("C")))
----

=== üíØPretty-Printing with `Show`

[source,scala]
include::{sourcedir}/Formula.scala[tag=show]

=== üíØPretty-Printing with `Show`

[source,scala]
----
// (A, Either[B, C])
val example =
  Formula.And(
    Formula.Type("A")
    Formula.Or(
      Formula.Type("B"),
      Formula.Type("C")))
example.show
----

[.console]
----
(A ‚àß (B ‚à® C))
----

=== Type ‚áí Formula

[source,scala]
----
include::{sourcedir}/ToFormula.scala[tag=ToFormula-def]
----
[.strategy]#Typeclass#

=== Type ‚áí Formula

[source,scala]
----
trait A
trait B
trait C

implicit val toFormulaA = ToFormula.reify[A]
implicit val toFormulaB = ToFormula.reify[B]
implicit val toFormulaC = ToFormula.reify[C]

ToFormula[(A, Either[B, C])].toFormula.show
----

[.console]
----
(A ‚àß (B ‚à® C))
----

=== Type ‚áí Formula

[source,scala]
----
include::{sourcedir}/ToFormula.scala[tag=product]

include::{sourcedir}/ToFormula.scala[tag=sum]
----

[.strategy]#Typeclass Derivation#

== Formulas ‚áí Proofs

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"

  node [shape=none]
  edge [color=grey fontcolor=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  formula -> proof [label=<<b>?</b>>,color=green3,fontcolor=green3,style=bold]
  program -> type [label="type\ninference",color=grey]
  type -> program [label="programmers",color=grey]

  formula -> type [xlabel="Curry-Howard  ",dir=both,color=grey]
  program -> proof [xlabel="  Curry-Howard",dir=both,color=grey]

  type -> formula [label=<<b>  typeclass</b>>,color=green3,fontcolor=green3,style=bold]
  proof -> program [xlabel=<<b>? </b>>,color=grey,fontcolor=grey,style=bold]
}
....

=== !

[source,scala]
----
trait Prover[Rule] {
  def prove(formula: Formula): Proof[Rule]
}

sealed trait Proof[Rule] // TODO
----

=== !

Please prove this type:

[.theory]#`Unit`#

[.fragment]
> üîä "Give me a `Unit`."

[.fragment]
[.whee]#`val proof = ()`#

=== !

Please prove this type:

[.theory]#`A`#

[.fragment]
> üîä "Give me an `A`."

[.fragment]
[.whee]#`val proof = ???`#

=== !

Please prove this type:

[.theory]#`A => A`#

[.fragment]
> üîä "If you give me an `A`, I'll give you an `A`."

[.fragment]
[.whee]#`val proof = (a: A) => a`#

=== !

Please prove this type:

[.theory]#`(A, B) => A`#

[.fragment]
> üîä "If you give me an `A` and a `B`, +
 I'll give you an `A`."

[.fragment]
[.whee]#`val proof = (a: A, _: B) => a`#

=== !

Please prove this type:

[.theory]#`A => Either[A, B]`#

[.fragment]
> üîä "If you give me an `A`, I'll give you an `A` or `B`."

[.fragment]
[.whee]#`val proof = (a: A) => Right(a)`#

=== !

[.notes]
--
We need to be explicit about when we are treating formulas as black boxes, i.e., functions like `A => A`, vs. treating formulas as _premises_ or _conclusions._
--

How did you know how to do that?

[.fragment]
Can we teach a computer?

=== More Complex Formulas

Please prove this type:

[.theory]#`(A, B) => Either[A, C]`#

[.fragment]
[.whee]
----
val proof1a: (A, B) => A =
  (a: A, _) => a

val proof2: A => Either[A, B] =
  (a: A) => Right(a)

val proof: (A, B) => Either[A, B] =
  proof1a andThen proof2
----

[.fragment]
====
Notice we didn't use this proof:

[.whee]
----
val proof1b: (A, B) => B =
  (_, b: B) => b
----
====

=== !

Formulas are _compositional_: they are composed of other formulas.

We have a set of primitive rules that translate formulas into simpler formulas.

Proof system: find rules to simplify formulas, until they are so simple they are axiomatically true.

The sequence of rules and formula transformations is the _proof_.

But we need a data structure to store the state: a _sequent_.

:GammaDelta: pass:m[stem:[Gamma |-- Delta]]
:entails: pass:m[stem:[|--]]

=== !

[cols=">,2,",grid=cols,frame=none]
|===
| If we had | Could we produce? | 

| | [.theory]#`(A, B) => Either[A, C]`# | no
|===
[.fragment]
[cols=">,2,",grid=cols,frame=none]
|===
| | ‚ÜôÔ∏é ‚Üì extract args |
| [.theory]#`(A, B)`# | [.theory]#`Either[A, C]`# | no 
|===
[.fragment]
[cols=">,2,",grid=cols,frame=none]
|===
| un-pair ‚Üì |  |
| [.theory]#`A, B`# | [.theory]#`Either[A, C]`# | no
|===
[.fragment]
[cols=">,2,",grid=cols,frame=none]
|===
|  | ‚Üì choose `A` | 
| [.theory]#`A, B`# | [.theory]#`A`# | *Yes!* 
|===

=== !

[cols=">,,",grid=cols,frame=none]
|===
| If we had | Could we produce? | 

| | [.theory]#`(A, B) => Either[A, C]`# | [.whee]`(a, _) => Right(a)`
| | ‚ÜôÔ∏é ‚Üì extract args | ‚Üë
| [.theory]#`(A, B)`# | [.theory]#`Either[A, C]`# | ‚Üë
| un-pair ‚Üì |  | ‚Üë
| [.theory]#`A, B`# | [.theory]#`Either[A, C]`# | [.whee]`(a, _) => Right(a)`
|  | ‚Üì choose `A` | ‚Üë [.whee]`_ andThen Right(_)`
| [.theory]#`A, B`# | [.theory]#`A`# | [.whee]`(a, _) => a` 
|===

=== !

[.theory]#`A => A`#

> üîä "If you give me an [.theory]#`A`#, I'll give you an [.theory]#`A`#."

[.fragment]
====
‚Üì

> üîä "If I [.whee]#presume# I have an [.theory]#`A`#, +
I can [.whee]#conclude# I have an [.theory]#`A`# (that I can give)."
====

[.fragment]
====
‚Üì

[.theory]#`A ‚ä¢ A`#
====

=== Sequents

[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#`A ‚ä¢ A`# | > üîä "If we presume [.theory]#`A`#, we can conclude [.theory]#`A`#."
|===

[.fragment]
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#{GammaDelta}# |
> üîä "If the premise [.theory]#Gamma# is true, then the conclusion [.theory]#Delta# is true."
|===

[.fragment]
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#{entails}# | > üîä "entails"
|===

[.fragment]
[source,scala]
----
case class Sequent(
  premises: List[Formula],
  conclusion: Formula)
----

== Proving Sequents

=== !

[.theory]#`A => A`#

> üîä "If you give me an [.theory]#`A`#, I'll give you an [.theory]#`A`#."

[.fragment]
====
‚Üì

[.theory]#`‚ä¢ A => A`#

> üîä "If we presume nothing, +
we can conclude [.theory]#`A => A`#."
====

=== !
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#`‚ä¢ A => A`# | > üîä "If we presume nothing, we can conclude [.theory]#`A => A`#."
|===

[.fragment]
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.theory]#`A ‚ä¢ A`# | > üîä "If I [.whee]#presume# I have an [.theory]#`A`#, I can [.whee]#conclude# I have an [.theory]#`A`# (that I can give)."
|===

[.fragment]
[cols="a,3a",grid=none,frame=none]
|===
^.^| [.big_emoji]#`‡≤†‚Äø‡≤†`# | > üîä "That's obviously true. I'm done!"
|===

=== Reduction ‚Üì

[.theory]
stem:[(A |-- B)/(|-- A => B)R=>]

> üîä "if we presume [.theory]#stem:[A |-- B]#, +
then we can conclude [.theory]#stem:[|-- A => B]#".

=== Deduction ‚Üë

[.theory]
stem:[(A |-- B)/(|-- A => B)R=>]

> üîä "if we conclude [.theory]#stem:[|-- A => B]#, +
then we can presume [.theory]#stem:[A |-- B]#".

=== Inference Rules

:Rimp: pass:m[stem:[(Gamma, A |-- B)/(Gamma |-- A => B)R=>]]

[cols="^.^a,>.^a,<2a",grid=none,frame=none]
|===
.2+| [.theory]#{Rimp}#
>| [.theory]#stem:[Gamma]# <| > üîä "whatever"
>| [.theory]#stem:[R=>]# <| > üîä "the rule R‚áí"
|===

[source,scala]
----
case LK.`R‚áí` => {
  case Sequent(g, Formula.Implies(a, b)) =>
    Deduction.Success(
      rule,
      NonEmptyList.of(Sequent(a :: g, b)))
}
----


=== Inference Rules

[.theory]
stem:[(<premise_1>, <premise_2>, ...)/(<conclusion>)<name>]

[.fragment]
Does this remind you of something?

[.fragment]
[grid=none,frame=none]
|===
^| Reduction ‚Üì | premises => conclusion
^| Deduction ‚Üë | conclusion => premises
|===

=== !

[.theory]
latexmath:[\dfrac{\dfrac{\dfrac{\dfrac{}{A, B \vdash A}Id}{A, B \vdash A \vee C}R\vee1}{A \wedge B \vdash A \vee C}L\wedge}{\vdash A \wedge B \Rightarrow A \vee C}R\Rightarrow]

== Proofs ‚áí Programs

[graphviz]
....
digraph x {
  pad=0.4
  size="9,15!"

  node [shape=none]
  edge [color=grey fontcolor=grey fontname="times-italic"]

  subgraph cluster_logic {
    label=<Logic>
    color="#ddddff"
    fontcolor="#9999ff"
    fontname="times-italic"
    style=dashed

    formula [fontcolor=blue3]
    proof [fontcolor=blue3]
    
    { rank=same formula proof }
  }
 
  subgraph cluster_prog {
    label="\nProgramming"
    labelloc=b
    color="#ffdddd"
    fontcolor="#ff9999"
    fontname="times-italic"
    style=dashed
    
    program [fontcolor=red3]
    type [fontcolor=red3]
    
    { rank=same type program }  
  }

  formula -> proof [label=<<b>proof system</b>>,color=green3,fontcolor=green3,style=bold]
  program -> type [label="type\ninference",color=grey]
  type -> program [label="programmers",color=grey]

  formula -> type [xlabel="Curry-Howard  ",dir=both,color=grey]
  program -> proof [xlabel="  Curry-Howard",dir=both,color=grey]

  type -> formula [label=<<b>  typeclass</b>>,color=green3,fontcolor=green3,style=bold]
  proof -> program [xlabel=<<b>? </b>>,color=green3,fontcolor=green3,style=bold]
}
....

== Summary

=== type => program in 3 Steps

[cols="a,2a"]
|===
^.^| type => [.accent]#formula# |
[.strategyNotBig]#reification# +
[.strategyNotBig]#algebraic data type# +
[.strategyNotBig]#typeclass#
^.^| formula => [.accent]#proof# |
[.strategyNotBig]#reification# +
[.strategyNotBig]#algebraic data type# +
[.strategyNotBig]#typeclass# +
[.strategyNotBig]#intepreter#
^.^| proof => [.accent]#program# |
[.strategyNotBig]#intepreter#
|===

=== !

[source,scala]
----
sealed trait Formula
----

[.fragment]
[source,scala]
----
case class Sequent(
  premises: List[Formula],
  conclusion: Formula)
----

[.fragment]
[source,scala]
----
case class System[Rule](rules: NonEmptySet[Rule])
----

[.fragment]
[source,scala]
----
trait Deducer[Rule] {
  def deduce(rule: Rule): Sequent => Deduction[Rule]
}
----

[.fragment]
[source,scala]
----
trait Prover[Rule] {
  def prove(sequent: Sequent): Proof[Rule]
}
----

=== Thank you!

Adam Rosien https://twitter.com/arosien[`@arosien`]

Inner Product LLC https://inner-product.com[`inner-product.com`]

[.accent]#**_Hire us to teach your team!_ ‚òùÔ∏é**#

'''

References and Links:

- https://github.com/Chymyst/curryhoward
- https://en.wikipedia.org/wiki/Sequent_calculus
- http://logitext.mit.edu/main